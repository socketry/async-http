<!DOCTYPE html>
<html>
	<head>
		
			<title>Async::HTTP</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="_static/icon.png"/>
		<link rel="stylesheet" href="_static/site.css" type="text/css" media="screen"/>
		
		<script src="_components/jquery/jquery.min.js"></script>
		<script src="_components/jquery-syntax/jquery.syntax.min.js"></script>
		<script src="_components/mermaid/mermaid.min.js"></script>
		
		<script src="_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
			
			let isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
			let config = {theme: 'light'};
			if (isDarkMode) config.theme = 'dark';
			else config.theme = 'forest';
			mermaid.initialize(config);
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="index.html">Project</a></header>
		
		<main>
			
	<h1>Async::HTTP</h1><p>An asynchronous client and server implementation of HTTP/1.0, HTTP/1.1 and HTTP/2 including TLS. Support for streaming requests and responses. Built on top of <a href="https://github.com/socketry/async">async</a> and <a href="https://github.com/socketry/async-io">async-io</a>. <a href="https://github.com/socketry/falcon">falcon</a> provides a rack-compatible server.</p>
<p><a href="https://github.com/socketry/async-http/actions?workflow=Development"><img src="https://github.com/socketry/async-http/workflows/Development/badge.svg" alt="Development Status"/></a></p>
<section id="installation"><h2>Installation</h2>
<p>Add this line to your application's Gemfile:</p>
<pre><code class="language-ruby">gem 'async-http'
</code></pre>
<p>And then execute:</p>
<pre><code>$ bundle
</code></pre>
<p>Or install it yourself as:</p>
<pre><code>$ gem install async-http
</code></pre>
</section><section id="usage"><h2>Usage</h2>
<p>Please browse the <a href="source/index.html">source code index</a> or refer to the guides below.</p>


</section><section id="post-json-data"><h3>Post JSON data</h3>
<p>Here is an example showing how to post a data structure as JSON to a remote resource:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'json'
require 'async'
require 'async/http/internet'

data = {'life' =&gt; 42}

Async do
	# Make a new internet:
	internet = Async::HTTP::Internet.new
	
	# Prepare the request:
	headers = [['accept', 'application/json']]
	body = [JSON.dump(data)]
	
	# Issues a POST request:
	response = internet.post(&quot;https://httpbin.org/anything&quot;, headers, body)
	
	# Save the response body to a local file:
	pp JSON.parse(response.read)
ensure
	# The internet is closed for business:
	internet.close
end
</code></pre>
<p>Consider using <a href="https://github.com/socketry/async-rest">async-rest</a> instead.</p>
</section><section id="multiple-requests"><h3>Multiple Requests</h3>
<p>To issue multiple requests concurrently, you should use a barrier, e.g.</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async'
require 'async/barrier'
require 'async/http/internet'

TOPICS = [&quot;ruby&quot;, &quot;python&quot;, &quot;rust&quot;]

Async do
	internet = Async::HTTP::Internet.new
	barrier = Async::Barrier.new
	
	# Spawn an asynchronous task for each topic:
	TOPICS.each do |topic|
		barrier.async do
			response = internet.get &quot;https://www.google.com/search?q=#{topic}&quot;
			puts &quot;Found #{topic}: #{response.read.scan(topic).size} times.&quot;
		end
	end
	
	# Ensure we wait for all requests to complete before continuing:
	barrier.wait
ensure
	internet&amp;.close
end
</code></pre>
</section><section id="limiting-requests"><h4>Limiting Requests</h4>
<p>If you need to limit the number of simultaneous requests, use a semaphore.</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async'
require 'async/barrier'
require 'async/semaphore'
require 'async/http/internet'

TOPICS = [&quot;ruby&quot;, &quot;python&quot;, &quot;rust&quot;]

Async do
	internet = Async::HTTP::Internet.new
	barrier = Async::Barrier.new
	semaphore = Async::Semaphore.new(2, parent: barrier)
	
	# Spawn an asynchronous task for each topic:
	TOPICS.each do |topic|
		semaphore.async do
			response = internet.get &quot;https://www.google.com/search?q=#{topic}&quot;
			puts &quot;Found #{topic}: #{response.read.scan(topic).size} times.&quot;
		end
	end
	
	# Ensure we wait for all requests to complete before continuing:
	barrier.wait
ensure
	internet&amp;.close
end
</code></pre>
</section><section id="persistent-connections"><h3>Persistent Connections</h3>
<p>To keep connections alive, install the <code>thread-local</code> gem,
require <code>async/http/internet/instance</code>, and use the <code>instance</code>, e.g.</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async'
require 'async/http/internet/instance'

Async do
  internet = Async::HTTP::Internet.instance
	response = internet.get &quot;https://www.google.com/search?q=test&quot;
	puts &quot;Found #{response.read.size} results.&quot;
end
</code></pre>
</section><section id="downloading-a-file"><h3>Downloading a File</h3>
<p>Here is an example showing how to download a file and save it to a local path:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async'
require 'async/http/internet'

Async do
	# Make a new internet:
	internet = Async::HTTP::Internet.new
	
	# Issues a GET request to Google:
	response = internet.get(&quot;https://www.google.com/search?q=kittens&quot;)
	
	# Save the response body to a local file:
	response.save(&quot;/tmp/search.html&quot;)
ensure
	# The internet is closed for business:
	internet.close
end
</code></pre>
</section><section id="basic-client/server"><h3>Basic Client/Server</h3>
<p>Here is a basic example of a client/server running in the same reactor:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async'
require 'async/http/server'
require 'async/http/client'
require 'async/http/endpoint'
require 'async/http/protocol/response'

endpoint = Async::HTTP::Endpoint.parse('http://127.0.0.1:9294')

app = lambda do |request|
	Protocol::HTTP::Response[200, {}, [&quot;Hello World&quot;]]
end

server = Async::HTTP::Server.new(app, endpoint)
client = Async::HTTP::Client.new(endpoint)
	
Async do |task|
	server_task = task.async do
		server.run
	end
	
	response = client.get(&quot;/&quot;)
	
	puts response.status
	puts response.read
	
	server_task.stop
end
</code></pre>
</section><section id="advanced-verification"><h3>Advanced Verification</h3>
<p>You can hook into SSL certificate verification to improve server verification.</p>
<pre><code class="language-ruby">require 'async'
require 'async/http'

# These are generated from the certificate chain that the server presented.
trusted_fingerprints = {
	&quot;dac9024f54d8f6df94935fb1732638ca6ad77c13&quot; =&gt; true,
	&quot;e6a3b45b062d509b3382282d196efe97d5956ccb&quot; =&gt; true,
	&quot;07d63f4c05a03f1c306f9941b8ebf57598719ea2&quot; =&gt; true,
	&quot;e8d994f44ff20dc78dbff4e59d7da93900572bbf&quot; =&gt; true,
}

Async do
	endpoint = Async::HTTP::Endpoint.parse(&quot;https://www.codeotaku.com/index&quot;)
	
	# This is a quick hack/POC:
	ssl_context = endpoint.ssl_context
	
	ssl_context.verify_callback = proc do |verified, store_context|
		certificate = store_context.current_cert
		fingerprint = OpenSSL::Digest::SHA1.new(certificate.to_der).to_s
		
		if trusted_fingerprints.include? fingerprint
			true
		else
			Console.logger.warn(&quot;Untrusted Certificate Fingerprint&quot;){fingerprint}
			false
		end
	end
	
	endpoint = endpoint.with(ssl_context: ssl_context)
	
	client = Async::HTTP::Client.new(endpoint)
	
	response = client.get(endpoint.path)
	
	pp response.status, response.headers.fields, response.read
end
</code></pre>
</section><section id="timeouts"><h3>Timeouts</h3>
<p>Here's a basic example with a timeout:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'async/http/internet'

Async do |task|
	internet = Async::HTTP::Internet.new
	
	# Request will timeout after 2 seconds
	task.with_timeout(2) do
		response = internet.get &quot;https://httpbin.org/delay/10&quot;
	end
rescue Async::TimeoutError
	puts &quot;The request timed out&quot;
ensure
	internet&amp;.close
end
</code></pre>
</section><section id="performance"><h2>Performance</h2>
<p>On a 4-core 8-thread i7, running <code>ab</code> which uses discrete (non-keep-alive) connections:</p>
<pre><code>$ ab -c 8 -t 10 http://127.0.0.1:9294/
This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 127.0.0.1 (be patient)
Completed 5000 requests
Completed 10000 requests
Completed 15000 requests
Completed 20000 requests
Completed 25000 requests
Completed 30000 requests
Completed 35000 requests
Completed 40000 requests
Completed 45000 requests
Completed 50000 requests
Finished 50000 requests


Server Software:        
Server Hostname:        127.0.0.1
Server Port:            9294

Document Path:          /
Document Length:        13 bytes

Concurrency Level:      8
Time taken for tests:   1.869 seconds
Complete requests:      50000
Failed requests:        0
Total transferred:      2450000 bytes
HTML transferred:       650000 bytes
Requests per second:    26755.55 [#/sec] (mean)
Time per request:       0.299 [ms] (mean)
Time per request:       0.037 [ms] (mean, across all concurrent requests)
Transfer rate:          1280.29 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.0      0       0
Processing:     0    0   0.2      0       6
Waiting:        0    0   0.2      0       6
Total:          0    0   0.2      0       6

Percentage of the requests served within a certain time (ms)
  50%      0
  66%      0
  75%      0
  80%      0
  90%      0
  95%      1
  98%      1
  99%      1
 100%      6 (longest request)
</code></pre>
<p>On a 4-core 8-thread i7, running <code>wrk</code>, which uses 8 keep-alive connections:</p>
<pre><code>$ wrk -c 8 -d 10 -t 8 http://127.0.0.1:9294/
Running 10s test @ http://127.0.0.1:9294/
  8 threads and 8 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   217.69us    0.99ms  23.21ms   97.39%
    Req/Sec    12.18k     1.58k   17.67k    83.21%
  974480 requests in 10.10s, 60.41MB read
Requests/sec:  96485.00
Transfer/sec:      5.98MB
</code></pre>
<p>According to these results, the cost of handling connections is quite high, while general throughput seems pretty decent.</p>
</section><section id="semantic-model"><h2>Semantic Model</h2>
</section><section id="scheme"><h3>Scheme</h3>
<p>HTTP/1 has an implicit scheme determined by the kind of connection made to the server (either <code>http</code> or <code>https</code>), while HTTP/2 models this explicitly and the client indicates this in the request using the <code>:scheme</code> pseudo-header (typically <code>https</code>). To normalize this, <code>Async::HTTP::Client</code> and <code>Async::HTTP::Server</code> have a default scheme which is used if none is supplied.</p>
</section><section id="version"><h3>Version</h3>
<p>HTTP/1 has an explicit version while HTTP/2 does not expose the version in any way.</p>
</section><section id="reason"><h3>Reason</h3>
<p>HTTP/1 responses contain a reason field which is largely irrelevant. HTTP/2 does not support this field.</p>
</section><section id="contributing"><h2>Contributing</h2>
<ol>
<li>Fork it</li>
<li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>
<li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li>
<li>Push to the branch (<code>git push origin my-new-feature</code>)</li>
<li>Create new Pull Request</li>
</ol>
</section><section id="see-also"><h2>See Also</h2>
<ul>
<li><a href="https://github.com/socketry/benchmark-http">benchmark-http</a> — A benchmarking tool to report on web server concurrency.</li>
<li><a href="https://github.com/socketry/falcon">falcon</a> — A rack compatible server built on top of <code>async-http</code>.</li>
<li><a href="https://github.com/socketry/async-websocket">async-websocket</a> — Asynchronous client and server websockets.</li>
<li><a href="https://github.com/socketry/async-rest">async-rest</a> — A RESTful resource layer built on top of <code>async-http</code>.</li>
<li><a href="https://github.com/socketry/async-http-faraday">async-http-faraday</a> — A faraday adapter to use <code>async-http</code>.</li>
</ul>
</section><section id="license"><h2>License</h2>
<p>Released under the MIT license.</p>
<p>Copyright, 2018, by <a href="http://www.codeotaku.com/samuel-williams">Samuel G. D. Williams</a>.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>
</section>
				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>
